{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./dist/engine.js","webpack:///./dist/index.js","webpack:///./dist/shape.js","webpack:///./dist/tetra-shapes.js","webpack:///./test/index.js","webpack:///./test/ugly-shapes.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA,YAAY,mBAAO,CAAC,gCAAS;AAC7B,qBAAqB,mBAAO,CAAC,gCAAS;;AAEtC,kBAAkB,mBAAO,CAAC,8CAAgB;;AAE1C;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wC;;AAEA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA,sBAAsB,gBAAgB,O;AACtC;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,oBAAoB,mDAAmD;AACvE;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,e;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,Y;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,c;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,OAAO;;AAEP,mCAAmC,QAAQ;AAC3C;AACA,oBAAoB,oBAAoB,O;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,oBAAoB,gBAAgB,O;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA,Y;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA,iD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;;;;;;AC/WA,aAAa,mBAAO,CAAC,kCAAU;AAC/B,kBAAkB,mBAAO,CAAC,8CAAgB;;AAE1C,kBAAkB,uB;;;;;;;;;;;ACHlB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C,0BAA0B,qBAAqB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,e;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjDoD;;AAEd;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,Y;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kDAAU,kDAAkD,mDAAU;;AAErG;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;;;;;;;;;;;AClFD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./test/index.js\");\n","let Shape = require('./shape').Shape\r\nlet ShapeDimension = require('./shape').ShapeDimension\r\n\r\nlet tetraShapes = require('./tetra-shapes')\r\n\r\n/**\r\n * Implements the engine of a game\r\n */\r\n\r\nclass Engine {\r\n\r\n  /**\r\n   * Initializing new area\r\n   * @param {number} width is the width of the field of the game in squares\r\n   * @param {number} height is the height of the field of the game in squares\r\n   * @param {function} renderHandle The method that will be runned every time \r\n   *                   when game state will be changed. Receives game render data.\r\n   * @param {Array} default heap for a game\r\n   */\r\n  constructor(width = 15, height = 20, renderHandle, defaultHeap, additionalShapes) {\r\n    if(width <= 0 || height <= 0)\r\n      throw 'Size parameters of the game field are incorrect'\r\n\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    this._shapesSet = {};\r\n    for(let key in tetraShapes)\r\n      this._shapesSet[key] = tetraShapes[key];\r\n      \r\n    if(additionalShapes)\r\n      for(let key in additionalShapes)\r\n        this._shapesSet[key] = additionalShapes[key];\r\n\r\n    this._gameStatus = GAME_STATUS.INIT;    \r\n\r\n    this._heap = [];\r\n    if(defaultHeap && defaultHeap.length && defaultHeap[0].length) {\r\n\r\n      for(let y = 0; y < defaultHeap.length; y++) {\r\n        let row = [];\r\n        for(let x = 0; x < this.width; x++) { \r\n          row.push({\r\n            val: 0\r\n          });\r\n        }\r\n        this._heap.push(row);\r\n      }\r\n\r\n      let inversedDefaultHeap = defaultHeap.slice().reverse();\r\n      for(let y = 0; y < inversedDefaultHeap.length && y < this.height; y++) {\r\n        let row = inversedDefaultHeap[y];\r\n        for(let x = 0; x < row.length && x < this.width; x++) {\r\n          this._heap[y][x].val = inversedDefaultHeap[y][x]\r\n        }\r\n      }\r\n    }\r\n\r\n    if(renderHandle) {\r\n      renderHandle(this.state);\r\n      this._renderHandle = renderHandle;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new Shape\r\n   */\r\n  _newFigure() {\r\n    this._shape = this._nextShape ? this._nextShape : new Shape(this._shapesSet, parseInt(this.width / 2 - 3), this.height);\r\n    this._nextShape = new Shape(this._shapesSet, parseInt(this.width / 2 - 3), this.height);\r\n  }\r\n\r\n  /**\r\n   * Running a game or turn off a pause mode\r\n   */\r\n  start() {\r\n    if(this._gameStatus !== GAME_STATUS.INIT && this._gameStatus !== GAME_STATUS.PAUSE)\r\n      return false;\r\n\r\n    if(this._gameStatus == GAME_STATUS.INIT) {\r\n      this._newFigure();\r\n      this._gameStatus = GAME_STATUS.WORK;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn on a pause mode\r\n   */\r\n  pause() {\r\n    if(this._gameStatus !== GAME_STATUS.WORK)\r\n      return false;\r\n\r\n    this._gameStatus = GAME_STATUS.PAUSE;\r\n    return true;\r\n  }\r\n\r\n  moveLeft() {\r\n    if(this._gameStatus !== GAME_STATUS.WORK)\r\n     return;\r\n\r\n    if(!this._canShapeMove(0, -1))\r\n      return;\r\n\r\n    this._shape.position.X--;\r\n    this._renderHandle(this.state);\r\n  }\r\n\r\n  moveRight() { \r\n    if(this._gameStatus !== GAME_STATUS.WORK)\r\n     return;\r\n\r\n    if(!this._canShapeMove(0, 1))\r\n      return;\r\n\r\n    this._shape.position.X++;\r\n    this._renderHandle(this.state);\r\n  }\r\n\r\n  moveUp() { \r\n    if(this._gameStatus !== GAME_STATUS.WORK)\r\n     return;\r\n     \r\n    if(!this._canShapeMove(1, 0))\r\n      return;\r\n    \r\n    this._shape.position.Y++;\r\n    this._renderHandle(this.state);\r\n  }\r\n\r\n  moveDown() { \r\n    if(this._gameStatus !== GAME_STATUS.WORK)\r\n     return;\r\n\r\n    if(!this._canShapeMove(-1, 0)) {\r\n      if(!this._addShapeToHeap()) {\r\n        this._gameStatus = GAME_STATUS.OVER;\r\n        this._renderHandle(this.state);\r\n      }\r\n      return;\r\n    }\r\n      \r\n    \r\n    this._shape.position.Y--;\r\n    this._renderHandle(this.state);\r\n  }\r\n\r\n  _addShapeToHeap() {\r\n    let newRowForHeap = [];\r\n    for(let i = 0; i < this.width; i++)\r\n      newRowForHeap.push({\r\n        val: 0\r\n      });\r\n\r\n    for(let y = ShapeDimension - 1; y >= 0; y--) {\r\n      let row = this._shape.body[y];\r\n      for(let x = 0; x < ShapeDimension; x++) { \r\n          let cell = row[x];\r\n          if(cell) {\r\n            let areaIndexY = this._getAreaIndexYFromShape(y);\r\n            \r\n            if(areaIndexY >= this.height) {\r\n              //game over :)\r\n              return false;\r\n            }\r\n\r\n            while(areaIndexY >= this._heap.length) {\r\n              this._heap.push(newRowForHeap.slice());\r\n            }\r\n\r\n            let areaIndexX = this._getAreaIndexXFromShape(x);\r\n            this._heap[areaIndexY][areaIndexX] = {\r\n              val: 1,\r\n              class: this._shape.name\r\n            };\r\n          }\r\n      }\r\n    }\r\n\r\n    this._checkHeapForReduce();\r\n\r\n    this._newFigure();\r\n    this._renderHandle(this.state);\r\n\r\n    return true;\r\n  }\r\n\r\n  _checkHeapForReduce() {\r\n    let linesToRemove = [];\r\n    for(let y = this._heap.length - 1; y >= 0; y--) {\r\n      let row = this._heap[y];\r\n      let isThereEmptySquare = false;\r\n      for(let x = 0; x < row.length; x++) { \r\n        if(!this._heap[y][x].val) {\r\n          isThereEmptySquare = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if(!isThereEmptySquare)\r\n        linesToRemove.push(y);\r\n    }\r\n\r\n    let newHeap = []\r\n    for (let y = 0; y < this._heap.length; y++) {\r\n      if(linesToRemove.indexOf(y) == -1)\r\n        newHeap.push(this._heap[y]);\r\n    }\r\n\r\n    this._heap = newHeap;\r\n  }\r\n\r\n  rotate() { \r\n    if(this._gameStatus !== GAME_STATUS.WORK)\r\n     return;\r\n    \r\n    if(!this._canShapeMove(0, 0, this._shape.getRotatedBody()))\r\n      return;\r\n      \r\n    this._shape.rotate();\r\n    this._renderHandle(this.state);\r\n  }\r\n\r\n  rotateBack() { \r\n    if(this._gameStatus !== GAME_STATUS.WORK)\r\n     return;\r\n\r\n    if(!this._canShapeMove(0, 0, this._shape.getRotatedBackBody()))\r\n      return;\r\n    \r\n    this._shape.rotateBack();\r\n    this._renderHandle(this.state);\r\n  }\r\n\r\n  _getShapeIndexX(x) {\r\n    return x - this._shape.position.X;\r\n  }\r\n\r\n  _getShapeIndexY(y) {\r\n    return this._shape.position.Y + (ShapeDimension - 1) - y;\r\n  }\r\n\r\n  _getAreaIndexXFromShape(shapeX, delta = 0) {\r\n    return shapeX + this._shape.position.X + delta;\r\n  }\r\n\r\n  _getAreaIndexYFromShape(shapeY, delta = 0) {\r\n      return this._shape.position.Y + (ShapeDimension - 1) - shapeY + delta;\r\n  }\r\n\r\n  /**\r\n   * Specifies that can a shape move. \r\n   * If new coordinates of shape overlap with coordinates of heap \r\n   * or are outside the game area the shape can't move\r\n   * @param {*} deltaY specifies vertical moving distance\r\n   * @param {*} deltaX specifies horizontal moving distance\r\n   * @param {*} shapeBody specifies changed body of a shape, for example rotated body\r\n   */\r\n  _canShapeMove(deltaY, deltaX, shapeBody) {\r\n    if(!shapeBody)\r\n      shapeBody = this._shape.body;\r\n\r\n    for(let y = 0; y < shapeBody.length; y++) {\r\n      let row = shapeBody[y];\r\n      let areaIndexY = this._getAreaIndexYFromShape(y, deltaY);\r\n      \r\n      for(let x = 0; x < row.length; x++) {\r\n        let cell = row[x];\r\n        if(cell) {\r\n          let areaIndexX = this._getAreaIndexXFromShape(x, deltaX);\r\n\r\n          //check will the shape go over the walls and the ground\r\n          if(areaIndexY < 0 || areaIndexX < 0 || areaIndexX >= this.width)\r\n            return false;\r\n\r\n          if(this._isHeapSquare(areaIndexY, areaIndexX ))\r\n            return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  _isShapeSquare(y, x) {\r\n      if(!this._shape || !this._shape.body)\r\n        return false;\r\n      let row = this._shape.body[this._getShapeIndexY(y)];\r\n      return row && row[this._getShapeIndexX(x)];\r\n  }\r\n\r\n  _isHeapSquare(y, x) {\r\n    if(!this._heap)\r\n      return false;\r\n\r\n    return this._heap[y] && this._heap[y][x].val;\r\n  }\r\n\r\n  _getHeapClass(y, x) {\r\n    if(!this._heap)\r\n      return;\r\n\r\n    if(!this._heap[y] || !this._heap[y][x].val)\r\n      return;\r\n\r\n    return this._heap[y][x].class;\r\n  }\r\n\r\n  _isLeftEdge(y, x) {\r\n    return this._getShapeIndexX(x) == 0 && this._getShapeIndexY(y) >= 0 && this._getShapeIndexY(y) <= 4;\r\n  }\r\n\r\n  _isRightEdge(y, x) {\r\n    return this._getShapeIndexX(x) == 4 && this._getShapeIndexY(y) >= 0 && this._getShapeIndexY(y) <= 4;\r\n  }\r\n\r\n  _getBody() {\r\n    let body = [];\r\n    for (let y = this.height - 1; y >= 0; y--) {\r\n        let row = [];\r\n        for (let x = 0; x < this.width; x++) {\r\n          let isHeap = this._isHeapSquare(y, x);\r\n          let isShape = this._isShapeSquare(y, x);\r\n          let val = isHeap ? 2 : isShape ? 1 : 0; \r\n\r\n          row.push({\r\n              val: val,\r\n              cssClasses: [\r\n                isShape ? 'shape' : null,\r\n                isHeap ? 'heap' : null,\r\n                isShape ? this._shape.name + '' : null,\r\n                isHeap ? this._getHeapClass(y, x) : null\r\n              ]\r\n          });\r\n        }\r\n        body.push(row);\r\n\r\n    }\r\n    return body;\r\n  }\r\n\r\n  get state() {\r\n    return {\r\n      gameStatus: this._gameStatus,\r\n      body: this._getBody(),\r\n      shapeName: this._shape ? this._shape.name : null,\r\n      nextShapeName: this._nextShape ? this._nextShape.name : null,\r\n      nextShapeBody: this._nextShape ? this._nextShape.body : null\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Enum represents status of a game\r\n * \r\n * INIT - game was not started\r\n * WORK - game is running\r\n * PAUSE - game was temporary stopped\r\n * OVER - game was finished\r\n */\r\nconst GAME_STATUS = {\r\n  INIT: 0,\r\n  WORK: 1,\r\n  PAUSE: 2,\r\n  OVER: 3\r\n}\r\n\r\nmodule.exports = Engine;","let Engine = require('./engine')\r\nlet tetraShapes = require('./tetra-shapes')\r\n\r\nmodule.exports = { Engine, tetraShapes };","/**\r\n * Max dimension of every shape\r\n */\r\nconst ShapeDimension = 5;\r\n\r\n/**\r\n * Implements a falling shape\r\n */\r\nclass Shape {\r\n    constructor(shapesSet, X = 5, Y = 12) {\r\n        if(!shapesSet)\r\n            console.error('Set of shapes was not setted!')\r\n\r\n        this._shape = this._selectNextShape(shapesSet);\r\n\r\n        this.position = {\r\n           X: X,\r\n           Y: Y\r\n        };\r\n\r\n        this._calculateProperties();\r\n     }\r\n\r\n     /**\r\n      * Selecting next shape from the available set of shapes\r\n      * @private\r\n      */\r\n     _selectNextShape(shapesSet) {\r\n        let count = 0;\r\n        let selectedShape;\r\n        for (let prop in shapesSet) {\r\n           if (Math.random() < 1 / ++count)\r\n              selectedShape = prop;\r\n        }\r\n        \r\n        this.name = selectedShape;\r\n\r\n        return shapesSet[selectedShape];\r\n     }\r\n\r\n     /**\r\n      * Calculating all properties that change when a shape is rotated\r\n      * @private\r\n      */\r\n     _calculateProperties() {\r\n        this._calculatePaddings();\r\n     }\r\n\r\n     /**\r\n      * Calculating paddings\r\n      */\r\n     _calculatePaddings() {\r\n        let paddingLeft = ShapeDimension;\r\n        let paddingRight = ShapeDimension;\r\n        let paddingTop = -1;\r\n        let paddingBottom = -1;\r\n  \r\n        for (let y = 0; y < ShapeDimension; y++) {\r\n           for (let x = 0;  x < ShapeDimension; x++) {\r\n              if (this._shape[y][x]) {\r\n                if (paddingLeft > x)\r\n                   paddingLeft = x;\r\n\r\n                if (paddingTop < 0) \r\n                     paddingTop = y;\r\n              }\r\n           }\r\n        }\r\n  \r\n        for (let y = ShapeDimension - 1; y >= 0; y--) {\r\n           for (let x = ShapeDimension - 1;  x >= 0; x--) {\r\n              if (this._shape[y][x]) {\r\n                if (paddingRight > ShapeDimension - 1 - x)\r\n                    paddingRight = ShapeDimension - 1 - x;\r\n  \r\n                if (paddingBottom < 0)\r\n                    paddingBottom = ShapeDimension - 1 - y;\r\n              }\r\n           }\r\n        }\r\n  \r\n        this._paddingLeft = paddingLeft;\r\n        this._paddingRight = paddingRight;\r\n        this._paddingTop = paddingTop;\r\n        this._paddingBottom = paddingBottom;\r\n     }\r\n\r\n     /**\r\n      * rotating a shape clockwise\r\n      * @public\r\n      */\r\n     rotate() {  \r\n        this._shape = this.getRotatedBody();\r\n        this._calculateProperties();\r\n     }\r\n\r\n     getRotatedBody() {\r\n        let newShape = [];\r\n  \r\n        for (let x = 0;  x < ShapeDimension; x++) {\r\n           let newRow = [];\r\n           for (let y = ShapeDimension - 1; y >= 0; y--) {\r\n              newRow.push(this._shape[y][x]);\r\n           }\r\n           newShape.push(newRow);\r\n        }\r\n\r\n        return newShape;\r\n     }\r\n  \r\n     /**\r\n      * rotating a shape counterclockwise\r\n      * @public\r\n      */\r\n     rotateBack() {\r\n        this._shape = this.getRotatedBackBody();\r\n        this._calculateProperties();\r\n     }\r\n\r\n     getRotatedBackBody() {\r\n        let newShape = [];\r\n        for (let x = ShapeDimension - 1;  x >= 0; x--) {\r\n           let newRow = [];\r\n           for (let y = 0; y < ShapeDimension; y++) {\r\n              newRow.push(this._shape[y][x]);\r\n           }\r\n           newShape.push(newRow);\r\n        }\r\n\r\n        return newShape;\r\n     }\r\n\r\n     /**\r\n      * getting actual shape body\r\n      * @public\r\n      */\r\n     get body() {\r\n        return this._shape;\r\n     }\r\n  \r\n     /**\r\n      * getting top padding for shape relatively shape's border\r\n      * @public\r\n      */\r\n     get paddingTop() {\r\n        return this._paddingTop;\r\n     }\r\n  \r\n    /**\r\n      * getting bottom padding for shape relatively shape's border\r\n      * @public\r\n      */\r\n     get paddingBottom() {\r\n        return this._paddingBottom;\r\n     }\r\n  \r\n    /**\r\n      * getting right padding for shape relatively shape's border\r\n      * @public\r\n      */\r\n     get paddingRight() {\r\n        return this._paddingRight;\r\n     }\r\n\r\n    /**\r\n      * getting left padding for shape relatively shape's border\r\n      * @public\r\n      */\r\n     get paddingLeft() {\r\n        return this._paddingLeft;\r\n     }\r\n}\r\n\r\nmodule.exports = {\r\n    Shape,\r\n    ShapeDimension\r\n};","module.exports = {\r\n    IShape: [\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [1, 1, 1, 1, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    ZShape: [\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 1, 1, 0, 0],\r\n       [0, 0, 1, 1, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    SShape: [\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 1, 1, 0],\r\n       [0, 1, 1, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    LShape: [\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 1, 1, 1, 0],\r\n       [0, 1, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    JShape: [\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 1, 1, 1, 0],\r\n       [0, 0, 0, 1, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    OShape: [\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 1, 1, 0, 0],\r\n       [0, 1, 1, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    TShape: [\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 1, 1, 1, 0],\r\n       [0, 0, 1, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ]\r\n };\r\n ","\r\nimport { Engine as GameEngine } from '../dist/index'\r\n\r\nimport uglyshapes from './ugly-shapes'\r\n\r\nlet App = new Vue({\r\n    template:\r\n        `<table class=\"game-table\">\r\n            <tbody>\r\n                <tr v-for=\"row in gameState.body\">\r\n                    <td v-for=\"cell in row\"\r\n                        v-bind:class=\"cell.cssClasses\">\r\n                    </td>                    \r\n                </tr>\r\n            </tbody>\r\n        </table>`,\r\n    el: '#app',\r\n    data() {       \r\n        return {\r\n            gameState: {\r\n                body:[]\r\n            }\r\n        }\r\n    },\r\n    methods: {\r\n        render(gameState) {\r\n            if(gameState.gameStatus == 3)\r\n                alert('game over');\r\n            this.gameState = gameState;\r\n        },\r\n        onKeyDown(e) {\r\n            if (e && e.key && this) {\r\n               switch (e.key) {\r\n                case 'Insert':\r\n                    this.$gameEngine.start();\r\n                    break;\r\n                  case 'Insert':\r\n                    this.$gameEngine.rotateBack();\r\n                    break;\r\n                  case 'Delete':\r\n                    this.$gameEngine.rotate();\r\n                    break;\r\n                  case 'ArrowUp':\r\n                    this.$gameEngine.moveUp();\r\n                    break;\r\n                  case 'ArrowDown':\r\n                    this.$gameEngine.moveDown();\r\n                    break;\r\n                  case 'ArrowLeft':\r\n                    this.$gameEngine.moveLeft();\r\n                    break;\r\n                  case 'ArrowRight':\r\n                    this.$gameEngine.moveRight();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    beforeMount() {\r\n\r\n        let areaHeight = 15;\r\n        let areaWidth = 25;\r\n\r\n        let defaultHeap = [\r\n          [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\r\n          [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\r\n          [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],\r\n          [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\r\n          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\r\n          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n        ];\r\n        \r\n        this.$gameEngine = new GameEngine(areaHeight, areaWidth, this.render, defaultHeap, uglyshapes);\r\n\r\n        window.document.body.addEventListener('keydown', this.onKeyDown.bind(this));\r\n\r\n        this.$gameEngine.start();\r\n        setInterval(()=>{\r\n            this.$gameEngine.moveDown();\r\n        }, 1000)\r\n    }\r\n});\r\n","module.exports = {\r\n    EmptyShape: [\r\n       [0, 1, 1, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 1, 1, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    UglyShape1: [\r\n       [1, 1, 1, 1, 1],\r\n       [0, 1, 1, 1, 0],\r\n       [0, 1, 0, 1, 0],\r\n       [0, 1, 0, 1, 0],\r\n       [0, 1, 0, 1, 0],\r\n    ],\r\n    UglyShape2: [\r\n       [0, 0, 0, 0, 1],\r\n       [0, 0, 0, 0, 1],\r\n       [1, 1, 1, 1, 1],\r\n       [0, 0, 0, 0, 0],\r\n       [0, 0, 0, 0, 0],\r\n    ],\r\n    UglyShape3: [\r\n       [0, 1, 0, 0, 0],\r\n       [0, 1, 0, 0, 0],\r\n       [0, 1, 1, 0, 0],\r\n       [1, 1, 1, 1, 1],\r\n       [0, 1, 0, 1, 0],\r\n    ]\r\n };\r\n "],"sourceRoot":""}